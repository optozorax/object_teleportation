<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Softbody object teleportation</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
        }
    </style>
</head>

<body>
    <div id="loading">Loading WASM...</div>
    <script src="js/three.min.js"></script>
    <script src="js/dat.gui.min.js"></script>
    <script src="js/OrbitControls.js"></script>

    <script type="module">
        import init, { MeshHandle } from './wasm/pkg/wasm.js';

        // Global variables
        let scene, camera, renderer, controls;
        let meshHandle; // WASM handle
        let particlesObject, particlesObject2, particlesObject4; // THREE.js points objects
        let linesObject, linesObject2, linesObject4; // THREE.js lines objects
        let circle1Object, circle2Object, circle1TeleportedObject, circle2TeleportedObject; // Circle objects
        let gridHelper, axesHelper; // Debug helpers
        let coordinateLabels = []; // Text labels for coordinates
        let wasmMemory; // Reference to WASM memory

        // Pre-allocated typed arrays for performance
        let particleDataArray; // Pre-allocated Float32Array for particle data
        let lineIndicesArray; // Pre-allocated Uint32Array for line indices
        let disabledLinesArray; // Pre-allocated Uint8Array for disabled lines
        let circle1DataArray; // Pre-allocated Float32Array for circle1 data
        let circle2DataArray; // Pre-allocated Float32Array for circle2 data

        // Maximum sizes
        const MAX_PARTICLES = 22500;
        const MAX_LINES = 354620;

        // Physics constants
        const constants = {
            dt: 0.001,
            edgeSpringConstant: 50,
            dampingCoefficient: 10.0,
            globalDamping: 0.01,
            iterations: 30,

            scene_size: 30,
            scene_scale: 1.,
            scene_offset_x: -4.,
            scene_offset_y: 0.,
            scene_speed_x: 0.5,
            scene_speed_y: 0.,
            scene_portal_type: 0.,

            scene_portal1_x: -1.5,
            scene_portal1_y: 0.,
            scene_portal1_angle: 0.,
            scene_portal2_x: 1.5,
            scene_portal2_y: 0.,
            scene_portal2_angle: 0.,
            scene_mirror_portals: 1.,
        };

        const guidata = {
            run_simulation: false,
            scene: "default",
            particleSize: 2.5,
            particleColor: '#0ea100',
            line2Color: '#931f1f',
            line4Color: '#5032cc',
            lineWidth: 1,
            circle1Color: '#ff8800',
            circle2Color: '#0088ff',
            showDebugGrid: false,
            cameraScale: 5.0,
            draw_reflections: true,
        };

        const guidata_copy = {
            guidata_particleSize: guidata["particleSize"],
            guidata_particleColor: guidata["particleColor"],
            guidata_line2Color: guidata["line2Color"],
            guidata_line4Color: guidata["line4Color"],
            guidata_lineWidth: guidata["lineWidth"],
            guidata_circle1Color: guidata["circle1Color"],
            guidata_circle2Color: guidata["circle2Color"],
        };

        // Initialize pre-allocated arrays
        function initializeArrays() {
            // Particle data: max particles * 2 coordinates (x, y)
            particleDataArray = new Float32Array(MAX_PARTICLES * 2);
            
            // Line indices: max lines * 2 indices per line
            lineIndicesArray = new Uint32Array(MAX_LINES * 2);
            
            // Disabled lines: max lines * 1 byte per line
            disabledLinesArray = new Uint8Array(MAX_LINES);
            
            // Circle data: 3 floats each (x, y, radius)
            circle1DataArray = new Float32Array(3);
            circle2DataArray = new Float32Array(3);
        }

        // Copy data from WASM memory to pre-allocated arrays
        function copyWasmData(wasmPtr, targetArray, elementCount) {
            const wasmView = new targetArray.constructor(
                wasmMemory.buffer,
                wasmPtr,
                elementCount
            );
            targetArray.set(wasmView.subarray(0, elementCount));
        }

        const scenes = {
            "default": {
                ...constants,
                ...guidata_copy,
            },
            "rigid": {
                ...constants,
                ...guidata_copy,
                edgeSpringConstant: 500.,

                guidata_particleColor: "#cfca09",
            },
            "more rigid": {
                ...constants,
                ...guidata_copy,
                edgeSpringConstant: 1000.,

                guidata_particleColor: "#c00000",
            },
            "big": {
                ...constants,
                ...guidata_copy,
                scene_offset_x: -4.5,
                scene_scale: 2.,
            },
            "even bigger": {
                ...constants,
                ...guidata_copy,
                scene_scale: 4.,
                scene_offset_x: -6.,
                scene_speed_x: 2.,
            },
            "bigger rigid": {
                ...constants,
                ...guidata_copy,
                scene_scale: 4.,
                scene_offset_x: -6.,
                scene_speed_x: 2.,
                edgeSpringConstant: 500.,

                guidata_particleColor: "#cfca09",
            },
            "refraction": {
                ...constants,
                ...guidata_copy,
                scene_offset_x: -3.5,
                scene_offset_y: -1.3,
            },
            "reflection": {
                ...constants,
                ...guidata_copy,
                edgeSpringConstant: 500.,
                scene_offset_x: -3.5,
                scene_offset_y: -1.,

                guidata_particleColor: "#cfca09",
            },
            "small": {
                ...constants,
                ...guidata_copy,
                scene_offset_x: -2.55,
                scene_scale: 0.01,
                iterations: 1,
            },
            "no springs": {
                ...constants,
                ...guidata_copy,
                edgeSpringConstant: 0.,
                dampingCoefficient: 0.1,

                guidata_particleColor: "#ffffff",
            },
            "inside": {
                ...constants,
                ...guidata_copy,
                scene_offset_x: -1.5,
            },
            "kiss": {
                ...constants,
                ...guidata_copy,
                scene_portal1_x: -1.01,
                scene_portal2_x: 1.01,
                scene_portal1_angle: 1.,
            },
            "kiss 2": {
                ...constants,
                ...guidata_copy,
                scene_portal1_x: -1.01,
                scene_portal2_x: 1.01,
                scene_portal1_angle: 1.,
                scene_offset_x: 0.,
                scene_offset_y: 1.5,
                scene_speed_x: 0.,
                scene_speed_y: -0.5,
            },
            "monoportal": {
                ...constants,
                ...guidata_copy,
                scene_portal1_x: 0.,
                scene_portal2_x: 0.,
                scene_offset_x: -2.,
            },
            "monoportal inside": {
                ...constants,
                ...guidata_copy,
                scene_portal1_x: 0.,
                scene_portal2_x: 0.,
                scene_offset_x: 0.,
            },
            "wrong intersection": {
                ...constants,
                ...guidata_copy,
                scene_portal1_x: -0.95,
                scene_portal2_x: 0.95,
                scene_portal1_angle: 1.,
            },
            "regular portal": {
                ...constants,
                ...guidata_copy,
                scene_portal_type: 2.,
                scene_mirror_portals: 0.,

                guidata_circle1Color: "#8b8b8b",
                guidata_circle2Color: "#ffffff",
            },
            "perspective portal": {
                ...constants,
                ...guidata_copy,
                scene_portal_type: 1.,

                guidata_circle1Color: "#12ff00",
                guidata_circle2Color: "#ff002e",

            },
            "perspective portal, no springs": {
                ...constants,
                ...guidata_copy,
                scene_portal_type: 1.,
                edgeSpringConstant: 0.,
                dampingCoefficient: 0.1,

                guidata_particleColor: "#ffffff",
                guidata_circle1Color: "#12ff00",
                guidata_circle2Color: "#ff002e",
            },
            "perspective portal, rotation": {
                ...constants,
                ...guidata_copy,
                scene_portal_type: 1.,
                edgeSpringConstant: 420.,
                scene_offset_x: -3.5,
                scene_offset_y: -1.13,

                guidata_circle1Color: "#12ff00",
                guidata_circle2Color: "#ff002e",
                guidata_particleColor: "#cfca09",
            },
        };

        function initScene() {
            for (const [name, scene] of Object.entries(scenes)) {
                if (guidata.scene == name) {
                    for (const [key, value] of Object.entries(scene)) {
                        if (key.startsWith("guidata_")) {
                            guidata[key.slice("guidata_".length)] = value;
                        } else {
                            constants[key] = value;
                            meshHandle.set_constant(key, value);
                        }
                    }
                    break;
                }
            }
            particlesObject.material.color.set(guidata.particleColor);
            particlesObject2.material.color.set(guidata.line2Color);
            particlesObject4.material.color.set(guidata.line4Color);
            linesObject.material.color.set(guidata.particleColor);
            linesObject2.material.color.set(guidata.line2Color);
            linesObject4.material.color.set(guidata.line4Color);
            circle1Object.material.color.set(guidata.circle1Color);
            circle1Object.children[0].material.color.set(guidata.circle1Color);
            circle1TeleportedObject.material.color.set(guidata.circle1Color);
            circle1TeleportedObject.children[0].material.color.set(guidata.circle1Color);
            circle2Object.material.color.set(guidata.circle2Color);
            circle2Object.children[0].material.color.set(guidata.circle2Color);
            circle2TeleportedObject.material.color.set(guidata.circle2Color);
            circle2TeleportedObject.children[0].material.color.set(guidata.circle2Color);
            meshHandle.init();
            updateVisualization();
        }

        // Initialize everything
        async function init2() {
            try {
                // Load WASM module
                const wasmModule = await init();
                wasmMemory = wasmModule.memory;

                // Initialize pre-allocated arrays
                initializeArrays();

                // Hide loading screen
                document.getElementById('loading').style.display = 'none';

                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x111111);

                // Create orthographic camera for 2D view with proper frustum
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = guidata.cameraScale;
                camera = new THREE.OrthographicCamera(
                    -frustumSize * aspect / 2,
                    frustumSize * aspect / 2,
                    frustumSize / 2,
                    -frustumSize / 2,
                    -1000, // Much larger near/far planes to prevent clipping
                    1000
                );
                camera.position.z = 1;

                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                document.body.appendChild(renderer.domElement);

                // Add ambient light
                const light = new THREE.AmbientLight(0xffffff, 1.0);
                scene.add(light);

                // Create orbit controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.25;
                controls.enableRotate = false; // Disable rotation for 2D view
                controls.screenSpacePanning = true; // Pan in screen space
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.PAN,
                    MIDDLE: THREE.MOUSE.DOLLY,
                    RIGHT: THREE.MOUSE.PAN
                };

                // Create the simulation in WASM
                meshHandle = new MeshHandle();
                
                // Set initial constants
                for (const name in constants) {
                    meshHandle.set_constant(name, constants[name]);
                }

                // Create debug grid and axes
                createDebugHelpers();

                // Create initial visualization objects
                createVisualizationObjects();

                // Set up GUI
                setupGUI();

                // Handle window resize
                window.addEventListener('resize', onWindowResize);

                initScene();

                updateVisualization();

                // Start animation loop
                animate();

            } catch (error) {
                console.error("Error initializing application:", error);
                document.getElementById('loading').textContent =
                    'Error loading WASM: ' + error.message;
            }
        }

        function createDebugHelpers() {
            // Create grid helper
            gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
            gridHelper.rotation.x = Math.PI / 2; // Rotate to XY plane
            gridHelper.visible = guidata.showDebugGrid;
            scene.add(gridHelper);

            // Create axes helper
            axesHelper = new THREE.AxesHelper(1);
            axesHelper.visible = guidata.showDebugGrid;
            scene.add(axesHelper);

            // Create coordinate labels
            createCoordinateLabels();
        }

        function createCoordinateLabels() {
            // Clear existing labels
            coordinateLabels.forEach(label => scene.remove(label));
            coordinateLabels = [];

            if (!guidata.showDebugGrid) return;

            // Create labels for grid points
            for (let x = -5; x <= 5; x += 1) {
                for (let y = -5; y <= 5; y += 1) {
                    if (x === 0 && y === 0) continue; // Skip origin

                    // Create a separate canvas for each label
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const context = canvas.getContext('2d');
                    context.font = '20px Arial';
                    context.fillStyle = '#ffffff';
                    context.strokeStyle = '#000000';
                    context.lineWidth = 2;
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';

                    // Draw text with outline for better visibility
                    const text = `${x},${y}`;
                    context.strokeText(text, canvas.width / 2, canvas.height / 2);
                    context.fillText(text, canvas.width / 2, canvas.height / 2);

                    // Create texture from canvas
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.needsUpdate = true;
                    const material = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(material);
                    sprite.position.set(x, y, 0.1);
                    sprite.scale.set(0.2, 0.2, 1);
                    sprite.visible = guidata.showDebugGrid;
                    
                    scene.add(sprite);
                    coordinateLabels.push(sprite);
                }
            }
        }

        function createVisualizationObjects() {
            // Remove existing objects if any
            if (particlesObject) scene.remove(particlesObject);
            if (particlesObject2) scene.remove(particlesObject2);
            if (particlesObject4) scene.remove(particlesObject4);
            if (linesObject) scene.remove(linesObject);
            if (linesObject2) scene.remove(linesObject2);
            if (linesObject4) scene.remove(linesObject4);
            if (circle1Object) scene.remove(circle1Object);
            if (circle2Object) scene.remove(circle2Object);
            if (circle1TeleportedObject) scene.remove(circle1Object);
            if (circle2TeleportedObject) scene.remove(circle2Object);
            
            // Create lines
            createLines();

            // Create particles
            createParticles();

            // Create circles
            createCircles();
        }

        function createParticles() {
            let particleCount = meshHandle.get_particles_count();
            if (guidata.draw_reflections) {
                particleCount /= 3;
            }
            
            // Create geometry for normal particles
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3); // x, y, z (z will be 0)
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Create material for normal particles
            const material = new THREE.PointsMaterial({
                color: guidata.particleColor,
                size: guidata.particleSize,
                sizeAttenuation: false
            });
            
            // Create points object for normal particles
            particlesObject = new THREE.Points(geometry, material);
            particlesObject.frustumCulled = false;
            scene.add(particlesObject);

            // Create geometry for type 2 particles
            const geometry2 = new THREE.BufferGeometry();
            const positions2 = new Float32Array(particleCount * 3);
            geometry2.setAttribute('position', new THREE.BufferAttribute(positions2, 3));
            
            // Create material for type 2 particles
            const material2 = new THREE.PointsMaterial({
                color: guidata.line2Color,
                size: guidata.particleSize,
                sizeAttenuation: false
            });
            
            // Create points object for type 2 particles
            particlesObject2 = new THREE.Points(geometry2, material2);
            particlesObject2.frustumCulled = false;
            scene.add(particlesObject2);

            // Create geometry for type 4 particles
            const geometry4 = new THREE.BufferGeometry();
            const positions4 = new Float32Array(particleCount * 3);
            geometry4.setAttribute('position', new THREE.BufferAttribute(positions4, 3));
            
            // Create material for type 4 particles
            const material4 = new THREE.PointsMaterial({
                color: guidata.line4Color,
                size: guidata.particleSize,
                sizeAttenuation: false
            });
            
            // Create points object for type 4 particles
            particlesObject4 = new THREE.Points(geometry4, material4);
            particlesObject4.frustumCulled = false;
            scene.add(particlesObject4);
        }

        function createLines() {
            const lineCount = meshHandle.get_lines_count();
            
            // Create geometry for normal lines (type 0)
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(lineCount * 2 * 3); // 2 vertices per line, 3 coords per vertex
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Create material for normal lines
            const material = new THREE.LineBasicMaterial({
                color: guidata.particleColor,
                linewidth: guidata.lineWidth
            });
            
            // Create line segments object for normal lines
            linesObject = new THREE.LineSegments(geometry, material);
            linesObject.frustumCulled = false;
            scene.add(linesObject);

            // Create geometry for type 2 lines
            const geometry2 = new THREE.BufferGeometry();
            const positions2 = new Float32Array(lineCount * 2 * 3);
            geometry2.setAttribute('position', new THREE.BufferAttribute(positions2, 3));
            
            // Create material for type 2 lines
            const material2 = new THREE.LineBasicMaterial({
                color: guidata.line2Color,
                linewidth: guidata.lineWidth
            });
            
            // Create line segments object for type 2 lines
            linesObject2 = new THREE.LineSegments(geometry2, material2);
            linesObject2.frustumCulled = false;
            scene.add(linesObject2);

            // Create geometry for type 4 lines
            const geometry4 = new THREE.BufferGeometry();
            const positions4 = new Float32Array(lineCount * 2 * 3);
            geometry4.setAttribute('position', new THREE.BufferAttribute(positions4, 3));
            
            // Create material for type 4 lines
            const material4 = new THREE.LineBasicMaterial({
                color: guidata.line4Color,
                linewidth: guidata.lineWidth
            });
            
            // Create line segments object for type 4 lines
            linesObject4 = new THREE.LineSegments(geometry4, material4);
            linesObject4.frustumCulled = false;
            scene.add(linesObject4);
        }

        function createCircles() {
            let circleLines = 128;

            // Create circle 1 (orange)
            const circle1Geometry = new THREE.CircleGeometry(1, circleLines);
            const circle1Material = new THREE.MeshBasicMaterial({ 
                color: guidata.circle1Color,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            circle1Object = new THREE.Mesh(circle1Geometry, circle1Material);
            scene.add(circle1Object);

            // Create circle 2 (blue)
            const circle2Geometry = new THREE.CircleGeometry(1, circleLines);
            const circle2Material = new THREE.MeshBasicMaterial({ 
                color: guidata.circle2Color,
                transparent: true,
                opacity: 0.2,
                side: THREE.DoubleSide
            });
            circle2Object = new THREE.Mesh(circle2Geometry, circle2Material);
            scene.add(circle2Object);

            // Also create wireframe versions for better visibility
            const wireframe1Material = new THREE.RingGeometry(0.99, 1.01, circleLines);
            const wireframe1Mesh = new THREE.Mesh(wireframe1Material, new THREE.MeshBasicMaterial({ 
                color: guidata.circle1Color, 
                transparent: true, 
                opacity: 0.8 
            }));
            circle1Object.add(wireframe1Mesh);

            const wireframe2Material = new THREE.RingGeometry(0.99, 1.01, circleLines);
            const wireframe2Mesh = new THREE.Mesh(wireframe2Material, new THREE.MeshBasicMaterial({ 
                color: guidata.circle2Color, 
                transparent: true, 
                opacity: 0.8 
            }));
            circle2Object.add(wireframe2Mesh);

            // ---------------------------------------------------------------
            {
                // Create circle 1 (orange)
                const circle1TeleportedGeometry = new THREE.CircleGeometry(1, circleLines);
                const circle1TeleportedMaterial = new THREE.MeshBasicMaterial({ 
                    color: guidata.circle1TeleportedColor,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                circle1TeleportedObject = new THREE.Mesh(circle1TeleportedGeometry, circle1TeleportedMaterial);
                scene.add(circle1TeleportedObject);

                // Create circle 2 (blue)
                const circle2TeleportedGeometry = new THREE.CircleGeometry(1, circleLines);
                const circle2TeleportedMaterial = new THREE.MeshBasicMaterial({ 
                    color: guidata.circle2TeleportedColor,
                    transparent: true,
                    opacity: 0.2,
                    side: THREE.DoubleSide
                });
                circle2TeleportedObject = new THREE.Mesh(circle2TeleportedGeometry, circle2TeleportedMaterial);
                scene.add(circle2TeleportedObject);

                // Also create wireframe versions for better visibility
                const wireframe1Material = new THREE.RingGeometry(0.99, 1.01, circleLines);
                const wireframe1Mesh = new THREE.Mesh(wireframe1Material, new THREE.MeshBasicMaterial({ 
                    color: guidata.circle1TeleportedColor, 
                    transparent: true, 
                    opacity: 0.8 
                }));
                circle1TeleportedObject.add(wireframe1Mesh);

                const wireframe2Material = new THREE.RingGeometry(0.99, 1.01, circleLines);
                const wireframe2Mesh = new THREE.Mesh(wireframe2Material, new THREE.MeshBasicMaterial({ 
                    color: guidata.circle2TeleportedColor, 
                    transparent: true, 
                    opacity: 0.8 
                }));
                circle2TeleportedObject.add(wireframe2Mesh);
            }
        }

        function updateVisualization() {
            try {
                // Update particles
                const particleCount = meshHandle.get_particles_count();
                const particlesPtr = meshHandle.get_particles_buffer();

                // Handle dynamic particle count - recreate particle objects if needed
                const expectedParticlesVertices = particleCount * 3;
                if (particlesObject.geometry.attributes.position.array.length !== expectedParticlesVertices) {
                    scene.remove(particlesObject);
                    scene.remove(particlesObject2);
                    scene.remove(particlesObject4);
                    createParticles();
                }
                
                // Copy particle data to pre-allocated array
                copyWasmData(particlesPtr, particleDataArray, particleCount * 2);
                
                // Update particle positions based on draw_reflections setting
                if (guidata.draw_reflections) {
                    const thirdCount = particleCount / 3;

                    circle1TeleportedObject.visible = true;
                    circle2TeleportedObject.visible = true;

                    // Make sure all particle objects are visible when reflections are enabled
                    particlesObject.visible = true;
                    particlesObject2.visible = true;
                    particlesObject4.visible = true;
                    
                    // Update normal particles (first third)
                    const particlePositions = particlesObject.geometry.attributes.position.array;
                    for (let i = 0; i < thirdCount; i++) {
                        particlePositions[i * 3] = particleDataArray[i * 2];
                        particlePositions[i * 3 + 1] = particleDataArray[i * 2 + 1];
                        particlePositions[i * 3 + 2] = 0;
                    }
                    particlesObject.geometry.attributes.position.needsUpdate = true;
                    
                    // Update type 2 particles (second third)
                    const particlePositions2 = particlesObject2.geometry.attributes.position.array;
                    for (let i = 0; i < thirdCount; i++) {
                        const sourceIndex = Math.floor(thirdCount) + i;
                        particlePositions2[i * 3] = particleDataArray[sourceIndex * 2];
                        particlePositions2[i * 3 + 1] = particleDataArray[sourceIndex * 2 + 1];
                        particlePositions2[i * 3 + 2] = 0;
                    }
                    particlesObject2.geometry.attributes.position.needsUpdate = true;
                    
                    // Update type 4 particles (third third)
                    const particlePositions4 = particlesObject4.geometry.attributes.position.array;
                    for (let i = 0; i < thirdCount; i++) {
                        const sourceIndex = Math.floor(thirdCount * 2) + i;
                        particlePositions4[i * 3] = particleDataArray[sourceIndex * 2];
                        particlePositions4[i * 3 + 1] = particleDataArray[sourceIndex * 2 + 1];
                        particlePositions4[i * 3 + 2] = 0;
                    }
                    particlesObject4.geometry.attributes.position.needsUpdate = true;
                } else {
                    // Only show normal particles when reflections are disabled
                    particlesObject.visible = true;
                    const particlePositions = particlesObject.geometry.attributes.position.array;
                    for (let i = 0; i < particleCount; i++) {
                        particlePositions[i * 3] = particleDataArray[i * 2];
                        particlePositions[i * 3 + 1] = particleDataArray[i * 2 + 1];
                        particlePositions[i * 3 + 2] = 0;
                    }
                    particlesObject.geometry.attributes.position.needsUpdate = true;
                    
                    // Hide other particle objects by setting visibility to false
                    particlesObject2.visible = false;
                    particlesObject4.visible = false;

                    circle1TeleportedObject.visible = false;
                    circle2TeleportedObject.visible = false;
                }

                // Update lines
                const lineCount = meshHandle.get_lines_count();
                
                // Handle dynamic line count - recreate line objects if needed
                const expectedLineVertices = lineCount * 2 * 3;
                if (linesObject.geometry.attributes.position.array.length !== expectedLineVertices) {
                    scene.remove(linesObject);
                    scene.remove(linesObject2);
                    scene.remove(linesObject4);
                    createLines();
                }
                
                const linesPtr = meshHandle.get_lines_buffer();
                const disabledLinesPtr = meshHandle.get_disable_lines_buffer();
                
                // Copy line data to pre-allocated arrays
                copyWasmData(linesPtr, lineIndicesArray, lineCount * 2);
                copyWasmData(disabledLinesPtr, disabledLinesArray, lineCount);

                // Update line positions based on line type
                const linePositions = linesObject.geometry.attributes.position.array;
                const linePositions2 = linesObject2.geometry.attributes.position.array;
                const linePositions4 = linesObject4.geometry.attributes.position.array;
                
                // All line objects are always visible - their content is controlled by the loop below
                linesObject.visible = true;
                linesObject2.visible = true;
                linesObject4.visible = true;
                
                for (let i = 0; i < lineCount; i++) {
                    const idx1 = lineIndicesArray[i * 2];
                    const idx2 = lineIndicesArray[i * 2 + 1];
                    const lineType = disabledLinesArray[i];
                    
                    // Reset all line positions to origin first
                    linePositions[i * 6] = 0;
                    linePositions[i * 6 + 1] = 0;
                    linePositions[i * 6 + 2] = 0;
                    linePositions[i * 6 + 3] = 0;
                    linePositions[i * 6 + 4] = 0;
                    linePositions[i * 6 + 5] = 0;
                    
                    linePositions2[i * 6] = 0;
                    linePositions2[i * 6 + 1] = 0;
                    linePositions2[i * 6 + 2] = 0;
                    linePositions2[i * 6 + 3] = 0;
                    linePositions2[i * 6 + 4] = 0;
                    linePositions2[i * 6 + 5] = 0;
                    
                    linePositions4[i * 6] = 0;
                    linePositions4[i * 6 + 1] = 0;
                    linePositions4[i * 6 + 2] = 0;
                    linePositions4[i * 6 + 3] = 0;
                    linePositions4[i * 6 + 4] = 0;
                    linePositions4[i * 6 + 5] = 0;
                    
                    if (lineType === 1 || lineType === 3 || lineType === 5) {
                        // Hide disabled lines (already set to origin above)
                        continue;
                    } else if (lineType === 0) {
                        // Show normal lines
                        linePositions[i * 6] = particleDataArray[idx1 * 2];
                        linePositions[i * 6 + 1] = particleDataArray[idx1 * 2 + 1];
                        linePositions[i * 6 + 2] = 0;
                        
                        linePositions[i * 6 + 3] = particleDataArray[idx2 * 2];
                        linePositions[i * 6 + 4] = particleDataArray[idx2 * 2 + 1];
                        linePositions[i * 6 + 5] = 0;
                    } else if (lineType === 2) {
                        // Show type 2 lines
                        linePositions2[i * 6] = particleDataArray[idx1 * 2];
                        linePositions2[i * 6 + 1] = particleDataArray[idx1 * 2 + 1];
                        linePositions2[i * 6 + 2] = 0;
                        
                        linePositions2[i * 6 + 3] = particleDataArray[idx2 * 2];
                        linePositions2[i * 6 + 4] = particleDataArray[idx2 * 2 + 1];
                        linePositions2[i * 6 + 5] = 0;
                    } else if (lineType === 4) {
                        // Show type 4 lines
                        linePositions4[i * 6] = particleDataArray[idx1 * 2];
                        linePositions4[i * 6 + 1] = particleDataArray[idx1 * 2 + 1];
                        linePositions4[i * 6 + 2] = 0;
                        
                        linePositions4[i * 6 + 3] = particleDataArray[idx2 * 2];
                        linePositions4[i * 6 + 4] = particleDataArray[idx2 * 2 + 1];
                        linePositions4[i * 6 + 5] = 0;
                    }
                }
                linesObject.geometry.attributes.position.needsUpdate = true;
                linesObject2.geometry.attributes.position.needsUpdate = true;
                linesObject4.geometry.attributes.position.needsUpdate = true;

                // Update circles
                updateCircles();
                
            } catch (error) {
                console.error("Error updating visualization:", error);
            }
        }

        function updateCircles() {
            try {
                // Update circle 1
                const circle1Ptr = meshHandle.get_circle1_data();
                copyWasmData(circle1Ptr, circle1DataArray, 3);
                circle1Object.position.set(circle1DataArray[0], circle1DataArray[1], 0);
                circle1Object.scale.set(circle1DataArray[2], circle1DataArray[2], 1);

                // Update circle 2
                const circle2Ptr = meshHandle.get_circle2_data();
                copyWasmData(circle2Ptr, circle2DataArray, 3);
                circle2Object.position.set(circle2DataArray[0], circle2DataArray[1], 0);
                circle2Object.scale.set(circle2DataArray[2], circle2DataArray[2], 1);

                // Update circle 1 teleported
                const circle1TeleportedPtr = meshHandle.get_circle1_teleported_data();
                copyWasmData(circle1TeleportedPtr, circle1DataArray, 3);
                circle1TeleportedObject.position.set(circle1DataArray[0], circle1DataArray[1], 0);
                circle1TeleportedObject.scale.set(circle1DataArray[2], circle1DataArray[2], 1);

                // Update circle 2 teleported
                const circle2TeleportedPtr = meshHandle.get_circle2_teleported_data();
                copyWasmData(circle2TeleportedPtr, circle2DataArray, 3);
                circle2TeleportedObject.position.set(circle2DataArray[0], circle2DataArray[1], 0);
                circle2TeleportedObject.scale.set(circle2DataArray[2], circle2DataArray[2], 1);
            } catch (error) {
                console.error("Error updating circles:", error);
            }
        }

        function setupGUI() {
            const gui = new dat.GUI();

            gui.add(guidata, "run_simulation").name("Run simulation");

            gui.add(guidata, "scene", Object.keys(scenes)).onChange(value => {
                initScene();
            }).name("Scene");

            var obj = { add:function(){ 
                meshHandle.init();
                updateVisualization();
            }};
            gui.add(obj,'add').name("Reset");

            // Camera settings
            gui.add(guidata, "showDebugGrid").onChange(value => {
                gridHelper.visible = value;
                axesHelper.visible = value;
                coordinateLabels.forEach(label => label.visible = value);
                if (value) {
                    createCoordinateLabels();
                }
            }).name("Show debug grid");

            gui.add(guidata, "draw_reflections").onChange(value => {
                meshHandle.set_constant("draw_reflections", (+value) + 0.0);
                updateVisualization();
            }).name("Draw reflections").listen();

            // Visual settings
            const visualFolder = gui.addFolder("Visual Settings");
            visualFolder.add(guidata, "particleSize", 0.0, 10.0, 0.01).onChange(value => {
                particlesObject.material.size = value;
                particlesObject2.material.size = value;
                particlesObject4.material.size = value;
            }).listen();
            visualFolder.addColor(guidata, "particleColor").onChange(value => {
                particlesObject.material.color.set(value);
                linesObject.material.color.set(value);
            }).listen();
            visualFolder.addColor(guidata, "line2Color").onChange(value => {
                particlesObject2.material.color.set(value);
                linesObject2.material.color.set(value);
            }).listen();
            visualFolder.addColor(guidata, "line4Color").onChange(value => {
                particlesObject4.material.color.set(value);
                linesObject4.material.color.set(value);
            }).listen();
            visualFolder.addColor(guidata, "circle1Color").onChange(value => {
                circle1Object.material.color.set(value);
                circle1Object.children[0].material.color.set(value);

                circle1TeleportedObject.material.color.set(value);
                circle1TeleportedObject.children[0].material.color.set(value);
            }).listen();
            visualFolder.addColor(guidata, "circle2Color").onChange(value => {
                circle2Object.material.color.set(value);
                circle2Object.children[0].material.color.set(value);

                circle2TeleportedObject.material.color.set(value);
                circle2TeleportedObject.children[0].material.color.set(value);
            }).listen();

            // Physics parameters
            const physicsFolder = gui.addFolder("Physics Parameters");
            const sceneFolder = gui.addFolder("Scene Parameters");
            
            // Add controls for each constant
            for (const name in constants) {
                const value = constants[name];

                // Different ranges based on parameter
                let min, max, step, label;

                let clamps = {
                    "iterations": [1, 30, 1, "Iters"],
                    "edgeSpringConstant": [0, 1000, 1, "Spring force"],
                    "dt": [0.0001, 0.1, 0.0001, "Δt"],
                    "dampingCoefficient": [0, 50, 0.1, "Spring damping"],
                    "globalDamping": [0, 5, 0.01, "Speed damping"],

                    "scene_size": [0, 120, 1, "Grid size"],
                    "scene_scale": [0.01, 10., 0.01, "Scale"],
                    "scene_offset_x": [-5, 5, 0.01, "Offset.x"],
                    "scene_offset_y": [-5, 5, 0.01, "Offset.y"],
                    "scene_speed_x": [-5, 5, 0.01, "Speed.x"],
                    "scene_speed_y": [-5, 5, 0.01, "Speed.y"],
                    "scene_portal_type": [0, 2, 1, "Portal type"],

                    "scene_portal1_x": [-5, 5, 0.01, "Portal1.x"],
                    "scene_portal1_y": [-5, 5, 0.01, "Portal1.y"],
                    "scene_portal1_angle": [0, 2., 0.01, "Portal1.angle"],
                    "scene_portal2_x": [-5, 5, 0.01, "Portal2.x"],
                    "scene_portal2_y": [-5, 5, 0.01, "Portal2.y"],
                    "scene_portal2_angle": [0, 2., 0.01, "Portal2.angle"],
                    "scene_mirror_portals": [0, 1, 1, "Mirror portals"],
                };

                if (name in clamps) {
                    min = clamps[name][0];
                    max = clamps[name][1];
                    step = clamps[name][2];
                    label = clamps[name][3];
                } else {
                    min = 0;
                    max = 5;
                    step = 0.01;
                    label = name;
                }

                if (name.startsWith("scene_")) {
                    sceneFolder.add(constants, name, min, max, step).onChange(value => {
                        meshHandle.set_constant(name, value);

                        updateVisualization();
                    }).name(label).listen();
                } else {
                    physicsFolder.add(constants, name, min, max, step).onChange(value => {
                        if (name !== "iterations") {
                            // Forward the change to WASM
                            meshHandle.set_constant(name, value);
                        }
                    }).name(label).listen();
                }
            }
            physicsFolder.open();
            sceneFolder.open();
        }

        function updateCameraScale(scale) {
            const aspect = window.innerWidth / window.innerHeight;
            
            camera.left = -scale * aspect / 2;
            camera.right = scale * aspect / 2;
            camera.top = scale / 2;
            camera.bottom = -scale / 2;
            
            camera.updateProjectionMatrix();
        }

        function onWindowResize() {
            updateCameraScale(guidata.cameraScale);
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            try {
                if (guidata.run_simulation) {
                    // Step the physics simulation in WASM
                    for (let i = 0; i < constants.iterations; i++) {
                        meshHandle.step();
                    }
                    updateVisualization();
                }

                // Update controls and render
                controls.update();
                renderer.render(scene, camera);
            } catch (error) {
                console.error("Error in animation loop:", error);
            }
        }

        // Start the application
        init2().catch(console.error);
    </script>
</body>

</html>
