<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>2D Particle Viewer</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        canvas {
            display: block;
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
            color: white;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 8px;
        }
    </style>
</head>

<body>
    <div id="loading">Loading WASM...</div>
    <script src="js/three.min.js"></script>
    <script src="js/dat.gui.min.js"></script>
    <script src="js/OrbitControls.js"></script>

    <script type="module">
        import init, { MeshHandle } from './wasm/pkg/wasm.js';

        // Global variables
        let scene, camera, renderer, controls;
        let meshHandle; // WASM handle
        let particlesObject; // THREE.js points object
        let linesObject; // THREE.js lines object
        let circle1Object, circle2Object; // Circle objects
        let gridHelper, axesHelper; // Debug helpers
        let coordinateLabels = []; // Text labels for coordinates
        let wasmMemory; // Reference to WASM memory

        // Physics constants
        const constants = {
            dt: 0.01,
            edgeSpringConstant: 50,
            dampingCoefficient: 10.0,
            globalDamping: 0.01,
            iterations: 3
        };

        const guidata = {
            run_simulation: false,
            particleSize: 5.0,
            particleColor: '#0ea100',
            lineColor: '#fafafa',
            lineWidth: 1,
            circle1Color: '#ff8800',
            circle2Color: '#0088ff',
            showDebugGrid: false,
            cameraScale: 5.0 // Initial camera scale to see -5 to 5 coordinates
        };

        // Initialize everything
        async function init2() {
            try {
                // Load WASM module
                const wasmModule = await init();
                wasmMemory = wasmModule.memory;

                // Hide loading screen
                document.getElementById('loading').style.display = 'none';

                // Create scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x111111);

                // Create orthographic camera for 2D view with proper frustum
                const aspect = window.innerWidth / window.innerHeight;
                const frustumSize = guidata.cameraScale;
                camera = new THREE.OrthographicCamera(
                    -frustumSize * aspect / 2,
                    frustumSize * aspect / 2,
                    frustumSize / 2,
                    -frustumSize / 2,
                    -1000, // Much larger near/far planes to prevent clipping
                    1000
                );
                camera.position.z = 1;

                // Create renderer
                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);

                // Add ambient light
                const light = new THREE.AmbientLight(0xffffff, 1.0);
                scene.add(light);

                // Create orbit controls
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.25;
                controls.enableRotate = false; // Disable rotation for 2D view
                controls.screenSpacePanning = true; // Pan in screen space
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.PAN,
                    MIDDLE: THREE.MOUSE.DOLLY,
                    RIGHT: THREE.MOUSE.PAN
                };

                // Create the simulation in WASM
                meshHandle = new MeshHandle();
                
                // Set initial constants
                for (const name in constants) {
                    meshHandle.set_constant(name, constants[name]);
                }

                // Create debug grid and axes
                createDebugHelpers();

                // Create initial visualization objects
                createVisualizationObjects();

                // Set up GUI
                setupGUI();

                // Handle window resize
                window.addEventListener('resize', onWindowResize);

                updateVisualization();

                // Start animation loop
                animate();

            } catch (error) {
                console.error("Error initializing application:", error);
                document.getElementById('loading').textContent =
                    'Error loading WASM: ' + error.message;
            }
        }

        function createDebugHelpers() {
            // Create grid helper
            gridHelper = new THREE.GridHelper(20, 20, 0x444444, 0x222222);
            gridHelper.rotation.x = Math.PI / 2; // Rotate to XY plane
            gridHelper.visible = guidata.showDebugGrid;
            scene.add(gridHelper);

            // Create axes helper
            axesHelper = new THREE.AxesHelper(10);
            axesHelper.visible = guidata.showDebugGrid;
            scene.add(axesHelper);

            // Create coordinate labels
            createCoordinateLabels();
        }

        function createCoordinateLabels() {
            // Clear existing labels
            coordinateLabels.forEach(label => scene.remove(label));
            coordinateLabels = [];

            if (!guidata.showDebugGrid) return;

            // Create labels for grid points
            for (let x = -10; x <= 10; x += 1) {
                for (let y = -10; y <= 10; y += 1) {
                    if (x === 0 && y === 0) continue; // Skip origin

                    // Create a separate canvas for each label
                    const canvas = document.createElement('canvas');
                    canvas.width = 64;
                    canvas.height = 64;
                    const context = canvas.getContext('2d');
                    context.font = '20px Arial';
                    context.fillStyle = '#ffffff';
                    context.strokeStyle = '#000000';
                    context.lineWidth = 2;
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';

                    // Draw text with outline for better visibility
                    const text = `${x},${y}`;
                    context.strokeText(text, canvas.width / 2, canvas.height / 2);
                    context.fillText(text, canvas.width / 2, canvas.height / 2);

                    // Create texture from canvas
                    const texture = new THREE.CanvasTexture(canvas);
                    texture.needsUpdate = true;
                    const material = new THREE.SpriteMaterial({ map: texture });
                    const sprite = new THREE.Sprite(material);
                    sprite.position.set(x, y, 0.1);
                    sprite.scale.set(0.2, 0.2, 1);
                    sprite.visible = guidata.showDebugGrid;
                    
                    scene.add(sprite);
                    coordinateLabels.push(sprite);
                }
            }
        }

        function createVisualizationObjects() {
            // Remove existing objects if any
            if (particlesObject) scene.remove(particlesObject);
            if (linesObject) scene.remove(linesObject);
            if (circle1Object) scene.remove(circle1Object);
            if (circle2Object) scene.remove(circle2Object);
            
            // Create lines
            createLines();

            // Create particles
            createParticles();

            // Create circles
            createCircles();
        }

        function createParticles() {
            const particleCount = meshHandle.get_particles_count();
            
            // Create geometry for particles
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(particleCount * 3); // x, y, z (z will be 0)
            
            // Set initial positions (will be updated from WASM)
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Create material for particles
            const material = new THREE.PointsMaterial({
                color: guidata.particleColor,
                size: guidata.particleSize,
                sizeAttenuation: false
            });
            
            // Create points object
            particlesObject = new THREE.Points(geometry, material);
            particlesObject.frustumCulled = false;
            scene.add(particlesObject);
        }

        function createLines() {
            const lineCount = meshHandle.get_lines_count();
            
            // Create geometry for lines (we'll filter out disabled lines during update)
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(lineCount * 2 * 3); // 2 vertices per line, 3 coords per vertex
            
            // Set initial positions (will be updated from WASM)
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            
            // Create material for lines
            const material = new THREE.LineBasicMaterial({
                color: guidata.lineColor,
                linewidth: guidata.lineWidth
            });
            
            // Create line segments object
            linesObject = new THREE.LineSegments(geometry, material);
            scene.add(linesObject);
        }

        function createCircles() {
            let circleLines = 128;

            // Create circle 1 (orange)
            const circle1Geometry = new THREE.CircleGeometry(1, circleLines);
            const circle1Material = new THREE.MeshBasicMaterial({ 
                color: guidata.circle1Color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            circle1Object = new THREE.Mesh(circle1Geometry, circle1Material);
            scene.add(circle1Object);

            // Create circle 2 (blue)
            const circle2Geometry = new THREE.CircleGeometry(1, circleLines);
            const circle2Material = new THREE.MeshBasicMaterial({ 
                color: guidata.circle2Color,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            circle2Object = new THREE.Mesh(circle2Geometry, circle2Material);
            scene.add(circle2Object);

            // Also create wireframe versions for better visibility
            const wireframe1Material = new THREE.RingGeometry(0.98, 1.02, circleLines);
            const wireframe1Mesh = new THREE.Mesh(wireframe1Material, new THREE.MeshBasicMaterial({ 
                color: guidata.circle1Color, 
                transparent: true, 
                opacity: 0.8 
            }));
            circle1Object.add(wireframe1Mesh);

            const wireframe2Material = new THREE.RingGeometry(0.98, 1.02, circleLines);
            const wireframe2Mesh = new THREE.Mesh(wireframe2Material, new THREE.MeshBasicMaterial({ 
                color: guidata.circle2Color, 
                transparent: true, 
                opacity: 0.8 
            }));
            circle2Object.add(wireframe2Mesh);
        }

        function updateVisualization() {
            try {
                // Update particles
                const particleCount = meshHandle.get_particles_count();
                const particlesPtr = meshHandle.get_particles_buffer();
                const particleData = new Float32Array(
                    wasmMemory.buffer,
                    particlesPtr,
                    particleCount * 2  // 2 coordinates per particle
                );
                
                // Update particle positions
                const particlePositions = particlesObject.geometry.attributes.position.array;
                for (let i = 0; i < particleCount; i++) {
                    particlePositions[i * 3] = particleData[i * 2];       // x
                    particlePositions[i * 3 + 1] = particleData[i * 2 + 1]; // y
                    particlePositions[i * 3 + 2] = 0;                     // z = 0
                }
                particlesObject.geometry.attributes.position.needsUpdate = true;

                // Update lines
                const lineCount = meshHandle.get_lines_count();
                const linesPtr = meshHandle.get_lines_buffer();
                const lineIndices = new Uint32Array(
                    wasmMemory.buffer,
                    linesPtr,
                    lineCount * 2  // 2 indices per line
                );

                // Get disabled lines buffer
                const disabledLinesPtr = meshHandle.get_disable_lines_buffer();
                const disabledLines = new Uint8Array(
                    wasmMemory.buffer,
                    disabledLinesPtr,
                    lineCount  // 1 byte per line
                );
                
                // Update line positions based on particle positions
                const linePositions = linesObject.geometry.attributes.position.array;
                for (let i = 0; i < lineCount; i++) {
                    const idx1 = lineIndices[i * 2];
                    const idx2 = lineIndices[i * 2 + 1];
                    
                    if (disabledLines[i] === 1) {
                        // Hide disabled line by setting all vertices to the same point
                        linePositions[i * 6] = 0;     // x1
                        linePositions[i * 6 + 1] = 0; // y1
                        linePositions[i * 6 + 2] = 0; // z1
                        
                        linePositions[i * 6 + 3] = 0; // x2
                        linePositions[i * 6 + 4] = 0; // y2
                        linePositions[i * 6 + 5] = 0; // z2
                    } else {
                        // Show enabled line with proper positions
                        // First vertex of line
                        linePositions[i * 6] = particleData[idx1 * 2];       // x1
                        linePositions[i * 6 + 1] = particleData[idx1 * 2 + 1]; // y1
                        linePositions[i * 6 + 2] = 0;                         // z1 = 0
                        
                        // Second vertex of line
                        linePositions[i * 6 + 3] = particleData[idx2 * 2];       // x2
                        linePositions[i * 6 + 4] = particleData[idx2 * 2 + 1]; // y2
                        linePositions[i * 6 + 5] = 0;                         // z2 = 0
                    }
                }
                linesObject.geometry.attributes.position.needsUpdate = true;

                // Update circles
                updateCircles();
                
            } catch (error) {
                console.error("Error updating visualization:", error);
            }
        }

        function updateCircles() {
            try {
                // Update circle 1
                const circle1Ptr = meshHandle.get_circle1_data();
                const circle1Data = new Float32Array(wasmMemory.buffer, circle1Ptr, 3); // [x, y, radius]
                circle1Object.position.set(circle1Data[0], circle1Data[1], 0);
                circle1Object.scale.set(circle1Data[2], circle1Data[2], 1);

                // Update circle 2
                const circle2Ptr = meshHandle.get_circle2_data();
                const circle2Data = new Float32Array(wasmMemory.buffer, circle2Ptr, 3); // [x, y, radius]
                circle2Object.position.set(circle2Data[0], circle2Data[1], 0);
                circle2Object.scale.set(circle2Data[2], circle2Data[2], 1);
            } catch (error) {
                console.error("Error updating circles:", error);
            }
        }

        function setupGUI() {
            const gui = new dat.GUI();

            // Simulation control
            gui.add(guidata, "run_simulation");

            // Camera settings
            const cameraFolder = gui.addFolder("Camera Settings");
            cameraFolder.add(guidata, "showDebugGrid").onChange(value => {
                gridHelper.visible = value;
                axesHelper.visible = value;
                coordinateLabels.forEach(label => label.visible = value);
                if (value) {
                    createCoordinateLabels();
                }
            });
            cameraFolder.open();

            // Visual settings
            const visualFolder = gui.addFolder("Visual Settings");
            visualFolder.add(guidata, "particleSize", 1.0, 100.0, 0.1).onChange(value => {
                particlesObject.material.size = value;
            });
            visualFolder.addColor(guidata, "particleColor").onChange(value => {
                particlesObject.material.color.set(value);
            });
            visualFolder.addColor(guidata, "lineColor").onChange(value => {
                linesObject.material.color.set(value);
            });
            visualFolder.addColor(guidata, "circle1Color").onChange(value => {
                circle1Object.material.color.set(value);
                circle1Object.children[0].material.color.set(value);
            });
            visualFolder.addColor(guidata, "circle2Color").onChange(value => {
                circle2Object.material.color.set(value);
                circle2Object.children[0].material.color.set(value);
            });
            visualFolder.open();

            // Physics parameters
            const physicsFolder = gui.addFolder("Physics Parameters");
            
            // Add controls for each constant
            for (const name in constants) {
                const value = constants[name];

                // Different ranges based on parameter
                let min, max, step;

                if (name === "iterations") {
                    min = 1;
                    max = 10;
                    step = 1;
                } else if (name === 'edgeSpringConstant') {
                    min = 0;
                    max = 1000;
                    step = 0.1;
                } else if (name === 'dt') {
                    min = 0.001;
                    max = 0.1;
                    step = 0.001;
                } else if (name === 'dampingCoefficient') {
                    min = 0;
                    max = 50;
                    step = 0.01;
                } else {
                    min = 0;
                    max = 5;
                    step = 0.01;
                }

                physicsFolder.add(constants, name, min, max, step).onChange(value => {
                    if (name !== "iterations") {
                        // Forward the change to WASM
                        meshHandle.set_constant(name, value);
                    }
                });
            }
            physicsFolder.open();
        }

        function updateCameraScale(scale) {
            const aspect = window.innerWidth / window.innerHeight;
            
            camera.left = -scale * aspect / 2;
            camera.right = scale * aspect / 2;
            camera.top = scale / 2;
            camera.bottom = -scale / 2;
            
            camera.updateProjectionMatrix();
        }

        function onWindowResize() {
            updateCameraScale(guidata.cameraScale);
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);

            try {
                if (guidata.run_simulation) {
                    // Step the physics simulation in WASM
                    for (let i = 0; i < constants.iterations; i++) {
                        meshHandle.step();
                    }
                    updateVisualization();
                }

                // Update controls and render
                controls.update();
                renderer.render(scene, camera);
            } catch (error) {
                console.error("Error in animation loop:", error);
            }
        }

        // Start the application
        init2().catch(console.error);
    </script>
</body>

</html>
